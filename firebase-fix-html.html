<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Firebase Fix - REST API Edition</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    h1 {
      color: #ff6b6b;
      border-bottom: 2px solid #ff6b6b;
      padding-bottom: 10px;
    }
    h2 {
      color: #ff6b6b;
      margin-top: 30px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      border: 1px solid #ddd;
    }
    button {
      background-color: #ff6b6b;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
      font-weight: bold;
    }
    button:hover {
      background-color: #ff5252;
    }
    .success {
      color: #28a745;
      font-weight: bold;
    }
    .section {
      margin-bottom: 40px;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .note {
      background-color: #fff9c4;
      padding: 10px;
      border-radius: 5px;
      margin: 15px 0;
      border-left: 4px solid #ffd600;
    }
  </style>
</head>
<body>
  <h1>Firebase Fix - REST API Edition</h1>
  
  <div class="note">
    <p><strong>Important:</strong> This page provides fixes for Firebase WebChannel connection issues by using the REST API instead of the WebChannel protocol.</p>
  </div>

  <div class="section">
    <h2>REST API Fix</h2>
    <p>This fix creates a REST API client for Firestore that bypasses WebChannel completely. Copy and paste this into your browser console:</p>
    <pre id="rest-api-fix">// Firebase REST API Fix - Copy and paste this into your browser console
(function() {
  console.log('üîß Setting up Firebase REST API client...');
  
  // Project config
  const PROJECT_ID = 'blindtab-db';
  const API_KEY = 'AIzaSyDummyKeyForSecurity'; // Replace with your actual API key
  
  // Create a REST client for Firestore
  window.firestoreREST = {
    // Base URL for Firestore REST API
    baseUrl: `https://firestore.googleapis.com/v1/projects/${PROJECT_ID}/databases/(default)/documents`,
    
    // Get a document
    async get(collection, docId) {
      console.log(`üîç Getting document: ${collection}/${docId}`);
      try {
        const response = await fetch(`${this.baseUrl}/${collection}/${docId}?key=${API_KEY}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        return this._transformResponse(data);
      } catch (error) {
        console.error('‚ùå Error getting document:', error);
        throw error;
      }
    },
    
    // List documents in a collection
    async list(collection, limit = 100) {
      console.log(`üìã Listing documents in: ${collection}`);
      try {
        const response = await fetch(`${this.baseUrl}/${collection}?pageSize=${limit}&key=${API_KEY}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        return {
          docs: data.documents ? data.documents.map(doc => this._transformResponse(doc)) : []
        };
      } catch (error) {
        console.error('‚ùå Error listing documents:', error);
        throw error;
      }
    },
    
    // Create or update a document
    async set(collection, docId, data) {
      console.log(`üíæ Setting document: ${collection}/${docId}`);
      try {
        const response = await fetch(`${this.baseUrl}/${collection}/${docId}?key=${API_KEY}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            fields: this._transformRequest(data)
          })
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const responseData = await response.json();
        return this._transformResponse(responseData);
      } catch (error) {
        console.error('‚ùå Error setting document:', error);
        throw error;
      }
    },
    
    // Delete a document
    async delete(collection, docId) {
      console.log(`üóëÔ∏è Deleting document: ${collection}/${docId}`);
      try {
        const response = await fetch(`${this.baseUrl}/${collection}/${docId}?key=${API_KEY}`, {
          method: 'DELETE'
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return true;
      } catch (error) {
        console.error('‚ùå Error deleting document:', error);
        throw error;
      }
    },
    
    // Transform Firestore response to regular JS object
    _transformResponse(data) {
      if (!data.fields) return null;
      
      const result = {};
      for (const [key, value] of Object.entries(data.fields)) {
        result[key] = this._extractValue(value);
      }
      
      // Add document ID if available
      if (data.name) {
        const parts = data.name.split('/');
        result.id = parts[parts.length - 1];
      }
      
      return result;
    },
    
    // Extract value from Firestore field
    _extractValue(fieldValue) {
      const type = Object.keys(fieldValue)[0];
      const value = fieldValue[type];
      
      switch (type) {
        case 'stringValue':
        case 'integerValue':
        case 'doubleValue':
        case 'booleanValue':
          return value;
        case 'nullValue':
          return null;
        case 'mapValue':
          return this._transformResponse(value);
        case 'arrayValue':
          return value.values ? value.values.map(v => this._extractValue(v)) : [];
        case 'timestampValue':
          return new Date(value);
        default:
          console.warn('‚ö†Ô∏è Unknown field type:', type);
          return value;
      }
    },
    
    // Transform JS object to Firestore fields
    _transformRequest(data) {
      const fields = {};
      
      for (const [key, value] of Object.entries(data)) {
        // Skip id field
        if (key === 'id') continue;
        fields[key] = this._createFieldValue(value);
      }
      
      return fields;
    },
    
    // Create Firestore field value
    _createFieldValue(value) {
      if (value === null || value === undefined) {
        return { nullValue: null };
      }
      
      switch (typeof value) {
        case 'string':
          return { stringValue: value };
        case 'number':
          return Number.isInteger(value) ? 
            { integerValue: value.toString() } : 
            { doubleValue: value };
        case 'boolean':
          return { booleanValue: value };
        case 'object':
          if (Array.isArray(value)) {
            return {
              arrayValue: {
                values: value.map(v => this._createFieldValue(v))
              }
            };
          } else if (value instanceof Date) {
            return { timestampValue: value.toISOString() };
          } else {
            return {
              mapValue: {
                fields: this._transformRequest(value)
              }
            };
          }
        default:
          console.warn('‚ö†Ô∏è Unsupported value type:', typeof value);
          return { stringValue: String(value) };
      }
    }
  };
  
  // Test the REST client
  async function testRESTClient() {
    try {
      console.log('üß™ Testing REST client...');
      
      // Test document
      const testCollection = 'firebase_test';
      const testDocId = 'rest_test_' + Date.now();
      const testData = {
        message: 'Hello from REST API',
        timestamp: new Date(),
        number: 42,
        nested: {
          field: 'nested value'
        },
        array: [1, 2, 'three']
      };
      
      // Create test document
      await firestoreREST.set(testCollection, testDocId, testData);
      console.log('‚úÖ Document created successfully');
      
      // Get the document
      const doc = await firestoreREST.get(testCollection, testDocId);
      console.log('‚úÖ Document retrieved successfully:', doc);
      
      // Delete the document
      await firestoreREST.delete(testCollection, testDocId);
      console.log('‚úÖ Document deleted successfully');
      
      console.log('üéâ REST client is working! You can now use window.firestoreREST to interact with Firestore.');
    } catch (error) {
      console.error('‚ùå REST client test failed:', error);
    }
  }
  
  // Run the test
  testRESTClient();
  
  console.log('‚úÖ Firebase REST API client is ready to use!');
  console.log('üìù Usage examples:');
  console.log('  - Get document: firestoreREST.get("collection", "docId")');
  console.log('  - List documents: firestoreREST.list("collection")');
  console.log('  - Set document: firestoreREST.set("collection", "docId", { field: "value" })');
  console.log('  - Delete document: firestoreREST.delete("collection", "docId")');
})();</pre>
    <button onclick="copyToClipboard('rest-api-fix')">Copy REST API Fix</button>
  </div>

  <div class="section">
    <h2>Minified REST API Fix</h2>
    <p>Here's a minified version of the REST API fix for easier copying:</p>
    <pre id="minified-rest-api-fix">(function(){console.log("üîß Setting up Firebase REST API client...");const e="blindtab-db",t="AIzaSyDummyKeyForSecurity";window.firestoreREST={baseUrl:`https://firestore.googleapis.com/v1/projects/${e}/databases/(default)/documents`,async get(e,r){console.log(`üîç Getting document: ${e}/${r}`);try{const n=await fetch(`${this.baseUrl}/${e}/${r}?key=${t}`);if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const s=await n.json();return this._transformResponse(s)}catch(e){throw console.error("‚ùå Error getting document:",e),e}},async list(e,r=100){console.log(`üìã Listing documents in: ${e}`);try{const n=await fetch(`${this.baseUrl}/${e}?pageSize=${r}&key=${t}`);if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const s=await n.json();return{docs:s.documents?s.documents.map(e=>this._transformResponse(e)):[]}}catch(e){throw console.error("‚ùå Error listing documents:",e),e}},async set(e,r,n){console.log(`üíæ Setting document: ${e}/${r}`);try{const s=await fetch(`${this.baseUrl}/${e}/${r}?key=${t}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({fields:this._transformRequest(n)})});if(!s.ok)throw new Error(`HTTP error! status: ${s.status}`);const o=await s.json();return this._transformResponse(o)}catch(e){throw console.error("‚ùå Error setting document:",e),e}},async delete(e,r){console.log(`üóëÔ∏è Deleting document: ${e}/${r}`);try{const n=await fetch(`${this.baseUrl}/${e}/${r}?key=${t}`,{method:"DELETE"});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);return!0}catch(e){throw console.error("‚ùå Error deleting document:",e),e}},_transformResponse(e){if(!e.fields)return null;const t={};for(const[r,n]of Object.entries(e.fields))t[r]=this._extractValue(n);if(e.name){const r=e.name.split("/");t.id=r[r.length-1]}return t},_extractValue(e){const t=Object.keys(e)[0],r=e[t];switch(t){case"stringValue":case"integerValue":case"doubleValue":case"booleanValue":return r;case"nullValue":return null;case"mapValue":return this._transformResponse(r);case"arrayValue":return r.values?r.values.map(e=>this._extractValue(e)):[];case"timestampValue":return new Date(r);default:return console.warn("‚ö†Ô∏è Unknown field type:",t),r}},_transformRequest(e){const t={};for(const[r,n]of Object.entries(e))"id"!==r&&(t[r]=this._createFieldValue(n));return t},_createFieldValue(e){if(null==e)return{nullValue:null};switch(typeof e){case"string":return{stringValue:e};case"number":return Number.isInteger(e)?{integerValue:e.toString()}:{doubleValue:e};case"boolean":return{booleanValue:e};case"object":return Array.isArray(e)?{arrayValue:{values:e.map(e=>this._createFieldValue(e))}}:e instanceof Date?{timestampValue:e.toISOString()}:{mapValue:{fields:this._transformRequest(e)}};default:return console.warn("‚ö†Ô∏è Unsupported value type:",typeof e),{stringValue:String(e)}}}};async function r(){try{console.log("üß™ Testing REST client...");const e="firebase_test",t="rest_test_"+Date.now(),r={message:"Hello from REST API",timestamp:new Date,number:42,nested:{field:"nested value"},array:[1,2,"three"]};await firestoreREST.set(e,t,r),console.log("‚úÖ Document created successfully");const n=await firestoreREST.get(e,t);console.log("‚úÖ Document retrieved successfully:",n),await firestoreREST.delete(e,t),console.log("‚úÖ Document deleted successfully"),console.log("üéâ REST client is working! You can now use window.firestoreREST to interact with Firestore.")}catch(e){console.error("‚ùå REST client test failed:",e)}}r(),console.log("‚úÖ Firebase REST API client is ready to use!"),console.log("üìù Usage examples:"),console.log("  - Get document: firestoreREST.get(\"collection\", \"docId\")"),console.log("  - List documents: firestoreREST.list(\"collection\")"),console.log("  - Set document: firestoreREST.set(\"collection\", \"docId\", { field: \"value\" })"),console.log("  - Delete document: firestoreREST.delete(\"collection\", \"docId\")")})();</pre>
    <button onclick="copyToClipboard('minified-rest-api-fix')">Copy Minified REST API Fix</button>
  </div>

  <div class="section">
    <h2>Permanent Fix for firebase.ts</h2>
    <p>For a permanent fix, you can modify your firebase.ts file to use the REST API client:</p>
    <pre id="permanent-fix">// Import necessary Firebase modules
import { initializeApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator } from 'firebase/firestore';

// Firebase configuration
const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'blindtab-db.firebaseapp.com',
  projectId: 'blindtab-db',
  storageBucket: 'blindtab-db.appspot.com',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID'
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// REST API client for Firestore
export const firestoreREST = {
  baseUrl: `https://firestore.googleapis.com/v1/projects/${firebaseConfig.projectId}/databases/(default)/documents`,
  
  async get(collection, docId) {
    try {
      const response = await fetch(`${this.baseUrl}/${collection}/${docId}?key=${firebaseConfig.apiKey}`);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      return this._transformResponse(data);
    } catch (error) {
      console.error('Error getting document:', error);
      throw error;
    }
  },
  
  async list(collection, limit = 100) {
    try {
      const response = await fetch(`${this.baseUrl}/${collection}?pageSize=${limit}&key=${firebaseConfig.apiKey}`);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      return {
        docs: data.documents ? data.documents.map(doc => this._transformResponse(doc)) : []
      };
    } catch (error) {
      console.error('Error listing documents:', error);
      throw error;
    }
  },
  
  async set(collection, docId, data) {
    try {
      const response = await fetch(`${this.baseUrl}/${collection}/${docId}?key=${firebaseConfig.apiKey}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          fields: this._transformRequest(data)
        })
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const responseData = await response.json();
      return this._transformResponse(responseData);
    } catch (error) {
      console.error('Error setting document:', error);
      throw error;
    }
  },
  
  async delete(collection, docId) {
    try {
      const response = await fetch(`${this.baseUrl}/${collection}/${docId}?key=${firebaseConfig.apiKey}`, {
        method: 'DELETE'
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return true;
    } catch (error) {
      console.error('Error deleting document:', error);
      throw error;
    }
  },
  
  _transformResponse(data) {
    if (!data.fields) return null;
    
    const result = {};
    for (const [key, value] of Object.entries(data.fields)) {
      result[key] = this._extractValue(value);
    }
    
    if (data.name) {
      const parts = data.name.split('/');
      result.id = parts[parts.length - 1];
    }
    
    return result;
  },
  
  _extractValue(fieldValue) {
    const type = Object.keys(fieldValue)[0];
    const value = fieldValue[type];
    
    switch (type) {
      case 'stringValue':
      case 'integerValue':
      case 'doubleValue':
      case 'booleanValue':
        return value;
      case 'nullValue':
        return null;
      case 'mapValue':
        return this._transformResponse(value);
      case 'arrayValue':
        return value.values ? value.values.map(v => this._extractValue(v)) : [];
      case 'timestampValue':
        return new Date(value);
      default:
        console.warn('Unknown field type:', type);
        return value;
    }
  },
  
  _transformRequest(data) {
    const fields = {};
    
    for (const [key, value] of Object.entries(data)) {
      if (key === 'id') continue;
      fields[key] = this._createFieldValue(value);
    }
    
    return fields;
  },
  
  _createFieldValue(value) {
    if (value === null || value === undefined) {
      return { nullValue: null };
    }
    
    switch (typeof value) {
      case 'string':
        return { stringValue: value };
      case 'number':
        return Number.isInteger(value) ? 
          { integerValue: value.toString() } : 
          { doubleValue: value };
      case 'boolean':
        return { booleanValue: value };
      case 'object':
        if (Array.isArray(value)) {
          return {
            arrayValue: {
              values: value.map(v => this._createFieldValue(v))
            }
          };
        } else if (value instanceof Date) {
          return { timestampValue: value.toISOString() };
        } else {
          return {
            mapValue: {
              fields: this._transformRequest(value)
            }
          };
        }
      default:
        console.warn('Unsupported value type:', typeof value);
        return { stringValue: String(value) };
    }
  }
};

// For development, connect to emulator if needed
if (process.env.NODE_ENV === 'development') {
  connectFirestoreEmulator(db, 'localhost', 8080);
}

// Export both the regular Firestore instance and the REST client
export { db };
export default db;</pre>
    <button onclick="copyToClipboard('permanent-fix')">Copy Permanent Fix</button>
  </div>

  <div class="section">
    <h2>Usage Examples</h2>
    <p>Here's how to use the REST API client in your code:</p>
    <pre id="usage-examples">// Using the REST API client

// Get a document
firestoreREST.get('users', 'user123')
  .then(user => {
    console.log('User data:', user);
  })
  .catch(error => {
    console.error('Error getting user:', error);
  });

// List documents in a collection
firestoreREST.list('songs', 50)
  .then(result => {
    console.log('Songs:', result.docs);
  })
  .catch(error => {
    console.error('Error listing songs:', error);
  });

// Create or update a document
const songData = {
  title: 'My Song',
  artist: 'Artist Name',
  duration: 180,
  tags: ['rock', 'indie'],
  createdAt: new Date()
};

firestoreREST.set('songs', 'song123', songData)
  .then(song => {
    console.log('Song saved:', song);
  })
  .catch(error => {
    console.error('Error saving song:', error);
  });

// Delete a document
firestoreREST.delete('songs', 'song123')
  .then(() => {
    console.log('Song deleted successfully');
  })
  .catch(error => {
    console.error('Error deleting song:', error);
  });</pre>
    <button onclick="copyToClipboard('usage-examples')">Copy Usage Examples</button>
  </div>

  <script>
    function copyToClipboard(elementId) {
      const element = document.getElementById(elementId);
      const text = element.textContent;
      
      navigator.clipboard.writeText(text).then(() => {
        const button = element.nextElementSibling;
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.classList.add('success');
        
        setTimeout(() => {
          button.textContent = originalText;
          button.classList.remove('success');
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy text: ', err);
        alert('Failed to copy text. Please try again.');
      });
    }
  </script>
</body>
</html> 